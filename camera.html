<!DOCTYPE html>
<html>

<head>
    <title>Page Title</title>
</head>

<body>
    <!-- <video id="myVideo" autoplay muted playsinline></video> -->
    <video id="piVideo" autoplay playsinline></video>
    <!-- <button onclick="connectToPi()" type="button">Call</button> -->

    <!-- The core Firebase JS SDK is always required and must be listed first -->
    <script src="https://www.gstatic.com/firebasejs/7.1.0/firebase-app.js"></script>

    <!-- TODO: Add SDKs for Firebase products that you want to use
     https://firebase.google.com/docs/web/setup#available-libraries -->
    <script src="https://www.gstatic.com/firebasejs/7.1.0/firebase-analytics.js"></script>
    <script src="https://www.gstatic.com/firebasejs/7.1.0/firebase-firestore.js"></script>

    <script>
        // Your web app's Firebase configuration
        var firebaseConfig = {
            apiKey: "AIzaSyC2AMehEW9xsxtLdVKHzZG7ENNh2wrBNw0",
            authDomain: "mspi-a4b75.firebaseapp.com",
            databaseURL: "https://mspi-a4b75.firebaseio.com",
            projectId: "mspi-a4b75",
            storageBucket: "mspi-a4b75.appspot.com",
            messagingSenderId: "224698699586",
            appId: "1:224698699586:web:33bb9a289a097f74a302db",
            measurementId: "G-RBB4FBV72Q"
        };
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        firebase.analytics();

        var db = firebase.firestore();
        var servers = {
            iceServers: [{
                    urls: "stun:stun.l.google.com:19302"
                },
                {
                    urls: "stun:stun.services.mozilla.com"
                },
                {
                    urls: "turn:numb.viagenie.ca",
                    credential: "charlietheunicorn",
                    username: "mspi.temple@gmail.com"
                }
            ]
        };
        const dbCollection = "webrtctest";
        //   var myVideo = document.getElementById("myVideo");
        var piVideo = document.getElementById("piVideo");
        var cameraId = "Pi1";

        //Should fetch from firebase
        var clientId = "TestClient1";

        //Variable that holds the ice candidate listener.
        let iceListener = null;


        let hasLocalDesc = false;
        let hasRemoteDesc = false;

        // var pc = new RTCPeerConnection(servers);
        // //Send local ice candidates
        // pc.onicecandidate = event =>
        //     event.candidate ?
        //     sendMessage("iceCandidate", event.candidate) :
        //     console.log("Sent All Ice");
        // //If WebRTC detects a stream added on other side, set video to that stream
        // pc.onaddstream = event => (piVideo.srcObject = event.stream);

        // //If disconnected, reset webrtc
        // pc.oniceconnectionstatechange = function () {
        //     console.log("Ice state:" + pc.iceConnectionState);
        //     if (pc.iceConnectionState == 'disconnected') {
        //         reset();
        //     }
        // }

        //Runs once to remove any previous traces of calls
        db.collection(dbCollection)
            .where("sender", "==", cameraId)
            .get()
            .then(function (querySnapshot) {
                querySnapshot.forEach(function (doc) {
                    doc.ref.delete();
                });
            })
            .catch(function (error) {
                console.log("Error getting documents: ", error);
            });

        //First init
        reset();

        function reset() {
            hasLocalDesc = false;
            hasRemoteDesc = false;

            pc.close();
            //Resets RTC object
            pc = new RTCPeerConnection(servers);

            pc.onicecandidate = event =>
                event.candidate ?
                sendMessage("iceCandidate", event.candidate) :
                console.log("Sent All Ice");
            pc.onaddstream = event => (piVideo.srcObject = event.stream);
            pc.oniceconnectionstatechange = function () {
                console.log("Ice state:" + pc.iceConnectionState);
                if (pc.iceConnectionState == 'disconnected') {
                    reset();
                }
            }
            //Disconnects listener since we don't have a connnection
            if (iceListener !== null) {
                iceListener();
            }
            piVideo.srcObject = null;
            console.log('Disconnected');
            initLocal(stream);
        }

        function hasUserMedia() {
            //check if the browser supports the WebRTC
            return !!(
                navigator.getUserMedia ||
                navigator.webkitGetUserMedia ||
                navigator.mozGetUserMedia
            );
        }

        //On first init cameraStream is null
        let cameraStream = null;
        function initLocal(cameraStream) {
            if (cameraStream !== null){
                addStream(cameraStream);
                pc.restartIce();
            }
            if (hasUserMedia()) {
                navigator.getUserMedia =
                    navigator.getUserMedia ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia;

                //enabling video and audio channels
                navigator.getUserMedia({
                        video: {
                            width: 1280,
                            height: 720
                        },
                        audio: true
                    },
                    function (stream) {
                        cameraStream = stream;
                        addStream(cameraStream);
                    },
                    function (err) {}
                );

                function addStream(stream){
                        //myVideo.srcObject = stream;
                        pc.addStream(stream);
                        //If Pi doesn't have a local 'address' yet, create one
                        if (!hasLocalDesc) {
                            pc
                                .createOffer()
                                .then(offer => pc.setLocalDescription(offer))
                                //Puts local 'address' into firebase for client to retrieve
                                .then(() => sendMessage("offer", pc.localDescription))
                                .then(() => console.log("Sent offer:"))
                                .then(() => console.log(pc.localDescription))
                                .then(() => hasLocalDesc = true)
                                .catch(() => console.log("Offer failed to be created"));
                        }
                }
            } else {
                alert("WebRTC is not supported");
            }
        }


        //Send message to firebase
        function sendMessage(type, data, options = {}) {
            let d = JSON.stringify(data);
            db.collection(dbCollection).add({
                sender: cameraId,
                what: type,
                data: d,
                options: options
            });
        }

        //RTCSessionDescription requires a RTCSessionDescriptionInit object to be created
        //This makes sure the object is correctly structured
        function convertToRTCSessionDescriptionInit(data) {
            let cache = {
                type: data.type,
                sdp: data.sdp
            };
            return cache;
        }

        function listenIce() {
            console.log("Listening for ice")
            iceListener = db.collection(dbCollection)
                .where("sender", "==", clientId)
                .onSnapshot(function (querySnapshot) {
                    querySnapshot.forEach(function (doc) {
                        let type = doc.data().what;
                        let data = JSON.parse(doc.data().data);
                        console.log(data);
                        if (type == "iceCandidate") {
                            //iceCandidates allow NAT Traversal so the two sides can find each other
                            pc.addIceCandidate(new RTCIceCandidate(data));
                            deleteRecord(doc.id);
                            console.log("Recieved Ice");
                        }
                        //console.log(`${doc.id} => ${doc.data().what}`);
                    });
                });
        }

        function deleteRecord(id) {
            //Delete signal so we don't process it again
            db.collection(dbCollection)
                .doc(id)
                .delete()
                .then(function () {
                    console.log("Document successfully deleted!");
                })
                .catch(function (error) {
                    console.error("Error removing document: ", error);
                });
        }

        //Attaches listener to listen for connetion from client
        //Runs function every time it detects a change
        db.collection(dbCollection)
            .where("sender", "==", clientId)
            .onSnapshot((querySnapshot) => {

                //Searched database for response from the offer we sent
                querySnapshot.forEach(function (doc) {
                    let type = doc.data().what;
                    let data = JSON.parse(doc.data().data);
                    //console.log(data);
                    if (type == "answer" && !hasRemoteDesc) {
                        data.type = type;
                        data = convertToRTCSessionDescriptionInit(data);
                        //If recieving an answer to our offer, set it as remote "address" for WebRTC
                        pc.setRemoteDescription(new RTCSessionDescription(data))
                            .then(() => deleteRecord(doc.id))
                            .catch(() => console.log("Answer failed to be set"));
                        hasRemoteDesc = true;
                        console.log("Recieved answer:");
                        console.log(data);

                        //We should have an address now, so we can start listening to ICE objects from client
                        listenIce();
                    } else if (type == "hangup") {
                        deleteRecord(doc.id);
                        reset();
                    }
                    //console.log(`${doc.id} => ${doc.data().what}`);
                });
            });
    </script>
</body>

</html>